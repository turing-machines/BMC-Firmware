From dc6fcc9da064279e883182c0bdd56b31b1336c0f Mon Sep 17 00:00:00 2001
From: Sam Edwards <sam@turingpi.com>
Date: Tue, 19 Mar 2024 16:52:21 -0600
Subject: [PATCH 4/5] i2c: mv64xxx: Allow continuing after read

The current FSM does not check the `send_stop` flag when completing a
read message; it just assumes any read message is always the end of the
transfer. This means subsequent messages go unprocessed, with no error
code to indicate otherwise.

Fixing this requires that the FSM check the `send_stop` flag and issue
the `SEND_RESTART` action instead of stop, but there are only two RCV_*
variants, one for receive-and-continue and one for receive-and-stop. We
could add another variant, however, the new FSM from the previous patch
makes it pretty clear that the RCV_* variants aren't really full actions
in their own respect, since they both implement the same observable
functionality as another action, just with an added read from the data
register first.

Therefore, convert the receive actions to a flag that can be set,
allowing any action to have an "...and also read" variant. The FSM can
then just use the plain SEND_RESTART action, but OR-in the flag, to
represent "read a byte, finish this message, go to the next message."

Signed-off-by: Sam Edwards <sam@turingpi.com>
---
 drivers/i2c/busses/i2c-mv64xxx.c | 47 +++++++++++---------------------
 1 file changed, 16 insertions(+), 31 deletions(-)

diff --git a/drivers/i2c/busses/i2c-mv64xxx.c b/drivers/i2c/busses/i2c-mv64xxx.c
index 2ead2d39dc3f..514d7ba5c9a3 100644
--- a/drivers/i2c/busses/i2c-mv64xxx.c
+++ b/drivers/i2c/busses/i2c-mv64xxx.c
@@ -115,9 +115,9 @@ enum mv64xxx_i2c_action {
 	MV64XXX_I2C_ACTION_SEND_ADDR_1,
 	MV64XXX_I2C_ACTION_SEND_ADDR_2,
 	MV64XXX_I2C_ACTION_SEND_DATA,
-	MV64XXX_I2C_ACTION_RCV_DATA,
-	MV64XXX_I2C_ACTION_RCV_DATA_STOP,
 	MV64XXX_I2C_ACTION_SEND_STOP,
+
+	MV64XXX_I2C_ACTION_RECEIVE = 0x80,
 };
 
 struct mv64xxx_i2c_regs {
@@ -394,16 +394,15 @@ mv64xxx_i2c_fsm(struct mv64xxx_i2c_data *drv_data, u32 status)
 
 	case MV64XXX_I2C_STATE_READ:
 		if (drv_data->bytes_left == 0) {
-			if (prev_state == MV64XXX_I2C_STATE_READ)
-				drv_data->action = MV64XXX_I2C_ACTION_RCV_DATA_STOP;
-			else
+			if (drv_data->send_stop || drv_data->aborting) {
 				drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
-			drv_data->state = MV64XXX_I2C_STATE_IDLE;
+				drv_data->state = MV64XXX_I2C_STATE_IDLE;
+			} else {
+				drv_data->action = MV64XXX_I2C_ACTION_SEND_RESTART;
+				drv_data->state = MV64XXX_I2C_STATE_RESTART;
+			}
 		} else {
-			if (prev_state == MV64XXX_I2C_STATE_READ)
-				drv_data->action = MV64XXX_I2C_ACTION_RCV_DATA;
-			else
-				drv_data->action = MV64XXX_I2C_ACTION_CONTINUE;
+			drv_data->action = MV64XXX_I2C_ACTION_CONTINUE;
 
 			/*
 			 * bytes_left counts the remaining read actions to send
@@ -418,6 +417,8 @@ mv64xxx_i2c_fsm(struct mv64xxx_i2c_data *drv_data, u32 status)
 			if (drv_data->bytes_left == 0)
 				drv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_ACK;
 		}
+		if (prev_state == MV64XXX_I2C_STATE_READ)
+			drv_data->action |= MV64XXX_I2C_ACTION_RECEIVE;
 		break;
 
 	case MV64XXX_I2C_STATE_WRITE:
@@ -457,6 +458,11 @@ static void mv64xxx_i2c_send_start(struct mv64xxx_i2c_data *drv_data)
 static void
 mv64xxx_i2c_do_action(struct mv64xxx_i2c_data *drv_data)
 {
+	if (drv_data->action & MV64XXX_I2C_ACTION_RECEIVE)
+		drv_data->msg->buf[drv_data->byte_posn++] =
+			readl(drv_data->reg_base + drv_data->reg_offsets.data);
+	drv_data->action &= ~MV64XXX_I2C_ACTION_RECEIVE;
+
 	switch(drv_data->action) {
 	case MV64XXX_I2C_ACTION_SEND_RESTART:
 		/* We should only get here if we have further messages */
@@ -503,27 +509,6 @@ mv64xxx_i2c_do_action(struct mv64xxx_i2c_data *drv_data)
 			drv_data->reg_base + drv_data->reg_offsets.control);
 		break;
 
-	case MV64XXX_I2C_ACTION_RCV_DATA:
-		drv_data->msg->buf[drv_data->byte_posn++] =
-			readl(drv_data->reg_base + drv_data->reg_offsets.data);
-		writel(drv_data->cntl_bits,
-			drv_data->reg_base + drv_data->reg_offsets.control);
-		break;
-
-	case MV64XXX_I2C_ACTION_RCV_DATA_STOP:
-		drv_data->msg->buf[drv_data->byte_posn++] =
-			readl(drv_data->reg_base + drv_data->reg_offsets.data);
-		if (!drv_data->atomic)
-			drv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;
-		writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,
-			drv_data->reg_base + drv_data->reg_offsets.control);
-		drv_data->block = 0;
-		if (drv_data->errata_delay)
-			udelay(5);
-
-		wake_up(&drv_data->waitq);
-		break;
-
 	case MV64XXX_I2C_ACTION_INVALID:
 	default:
 		dev_err(&drv_data->adapter.dev,
-- 
2.45.2

